on:
    push:
      branches:
        - main
env:
    AWS_REGION: us-east-1
    ECR_REPOSITORY: testaction
    ECS_SERVICE: mytestservice
    ECS_CLUSTER: myclustertest
    ECS_TASK_DEFINITION: mytesttd
    CONTAINER_NAME: "mytestcontainer"
jobs:
    deploy:
      name: Deploy
      runs-on: ubuntu-latest
      environment: development
      steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Set up JDK 11
          uses: actions/setup-java@v4 
          with:
            distribution: 'temurin'
            java-version: '11'
  
        - name: Build Spring Boot application
          run: mvn clean install

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4 
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_ACCESS_KEY_ID1 }}
            aws-region: ${{env.AWS_REGION}}

        - name: Login to Amazon ECR
          id: login-ecr
          uses: aws-actions/amazon-ecr-login@v2 
    
        - name: Build, tag, and push the image to Amazon ECR
          id: build-image
          env:
              ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
              ECR_REPOSITORY: ${{ secrets.REPO_NAME }}
          run: |
              docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
              docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
              echo "IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY:latest" >> $GITHUB_ENV

        - name: Install AWS CLI
          run: |
                  if ! command -v aws &> /dev/null; then
                  curl -sSf "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                  unzip awscliv2.zip
                  sudo ./aws/install
                  else
                  aws --version
                  aws --version 2>&1 | grep "aws-cli/2."
                  if [ $? -eq 0 ]; then
                      echo "AWS CLI version 2 is already installed."
                  else
                      echo "Updating AWS CLI..."
                      curl -sSf "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                      unzip awscliv2.zip
                      sudo ./aws/install --update
                  fi
                  fi

        - name: Update ECS service with new image
          run: |
            IMAGE="${{ env.IMAGE }}"
            
            # Fetch the current task definition
            CURRENT_TASK_DEF=$(aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query 'taskDefinition' --output json)
            
            # Debug: Output current task definition to log
            echo "Current task definition: $CURRENT_TASK_DEF"
            
            # Extract the task definition family
            FAMILY=$(echo $CURRENT_TASK_DEF | jq -r '.family')
            
            # Get the container definitions and update the image
            UPDATED_CONTAINER_DEFINITIONS=$(echo $CURRENT_TASK_DEF | jq --arg IMAGE "$IMAGE" --arg NAME "${{ env.CONTAINER_NAME }}" '.containerDefinitions | map(if .name == $NAME then .image = $IMAGE else . end)')
            
            # Add memory or memoryReservation to the container definition
            UPDATED_CONTAINER_DEFINITIONS=$(echo $UPDATED_CONTAINER_DEFINITIONS | jq '.[0].memory = 512')  # Replace '512' with your desired memory value in MiB
            
            # Build the new task definition JSON
            NEW_TASK_DEF=$(jq -n \
              --arg family "$FAMILY" \
              --argjson containerDefinitions "$UPDATED_CONTAINER_DEFINITIONS" \
              --arg taskRoleArn "$(echo $CURRENT_TASK_DEF | jq -r '.taskRoleArn')" \
              --arg executionRoleArn "$(echo $CURRENT_TASK_DEF | jq -r '.executionRoleArn')" \
              --arg networkMode "$(echo $CURRENT_TASK_DEF | jq -r '.networkMode')" \
              --argjson volumes "$(echo $CURRENT_TASK_DEF | jq '.volumes')" \
              --argjson placementConstraints "$(echo $CURRENT_TASK_DEF | jq '.placementConstraints')" \
              --argjson requiresCompatibilities "$(echo $CURRENT_TASK_DEF | jq '.requiresCompatibilities')" \
              --arg cpu "$(echo $CURRENT_TASK_DEF | jq -r '.cpu')" \
              --arg memory "$(echo $CURRENT_TASK_DEF | jq -r '.memory')" \
              --arg pidMode "$(echo $CURRENT_TASK_DEF | jq -r '.pidMode')" \
              --arg ipcMode "$(echo $CURRENT_TASK_DEF | jq -r '.ipcMode')" \
              --argjson proxyConfiguration "$(echo $CURRENT_TASK_DEF | jq '.proxyConfiguration')" \
              --argjson inferenceAccelerators "$(echo $CURRENT_TASK_DEF | jq '.inferenceAccelerators')" \
              --argjson ephemeralStorage "$(echo $CURRENT_TASK_DEF | jq '.ephemeralStorage')" \
              --argjson runtimePlatform "$(echo $CURRENT_TASK_DEF | jq '.runtimePlatform')" \
              '{ 
                family: $family,
                taskRoleArn: $taskRoleArn,
                executionRoleArn: $executionRoleArn,
                networkMode: $networkMode,
                containerDefinitions: $containerDefinitions,
                volumes: $volumes,
                placementConstraints: $placementConstraints,
                requiresCompatibilities: $requiresCompatibilities,
                cpu: $cpu,
                memory: $memory,
                pidMode: $pidMode,
                ipcMode: $ipcMode,
                proxyConfiguration: $proxyConfiguration,
                inferenceAccelerators: $inferenceAccelerators,
                ephemeralStorage: $ephemeralStorage,
                runtimePlatform: $runtimePlatform
              }')

            # Save the new task definition to a file
            echo "$NEW_TASK_DEF" > new-task-def.json
            
            # Debug: Check if the file exists and output its contents
            ls -l new-task-def.json
            cat new-task-def.json
            
            # Register the new task definition revision
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://new-task-def.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            # Update ECS service to use the new task definition revision
            aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition $NEW_TASK_DEF_ARN
            aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}


      
        # - name: Update ECS service with new image
        #   run: |
        #             IMAGE="${{ env.IMAGE }}"
                    
        #             # Fetch the current task definition
        #             CURRENT_TASK_DEF=$(aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query 'taskDefinition' --output json)
                    
        #             # Debug: Output current task definition to log
        #             echo "Current task definition: $CURRENT_TASK_DEF"
                    
        #             # Extract the task definition family
        #             FAMILY=$(echo $CURRENT_TASK_DEF | jq -r '.family')
                    
        #             # Get the container definitions and update the image
        #             UPDATED_CONTAINER_DEFINITIONS=$(echo $CURRENT_TASK_DEF | jq --arg IMAGE "$IMAGE" --arg NAME "${{ env.CONTAINER_NAME }}" '.containerDefinitions | map(if .name == $NAME then .image = $IMAGE else . end)')
                    
        #             # Debug: Output updated container definitions to log
        #             echo "Updated container definitions: $UPDATED_CONTAINER_DEFINITIONS"
                    
        #             # Create a temporary JSON file with updated container definitions
        #             echo "$UPDATED_CONTAINER_DEFINITIONS" > updated-containers.json
                    
        #             # Debug: Check if the file exists and output its contents
        #             ls -l updated-containers.json
        #             cat updated-containers.json
                    
        #             # Register the new task definition revision
        #             NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
        #               --family $FAMILY \
        #               --task-role-arn "$(echo $CURRENT_TASK_DEF | jq -r '.taskRoleArn')" \
        #               --execution-role-arn "$(echo $CURRENT_TASK_DEF | jq -r '.executionRoleArn')" \
        #               --network-mode "$(echo $CURRENT_TASK_DEF | jq -r '.networkMode')" \
        #               --container-definitions file://updated-containers.json \
        #               --volumes "$(echo $CURRENT_TASK_DEF | jq -c '.volumes')" \
        #               --placement-constraints "$(echo $CURRENT_TASK_DEF | jq -c '.placementConstraints')" \
        #               --requires-compatibilities "$(echo $CURRENT_TASK_DEF | jq -c '.requiresCompatibilities')" \
        #               --cpu "$(echo $CURRENT_TASK_DEF | jq -r '.cpu')" \
        #               --memory "$(echo $CURRENT_TASK_DEF | jq -r '.memory')" \
        #               --tags "$(echo $CURRENT_TASK_DEF | jq -c '.tags')" \
        #               --pid-mode "$(echo $CURRENT_TASK_DEF | jq -r '.pidMode')" \
        #               --ipc-mode "$(echo $CURRENT_TASK_DEF | jq -r '.ipcMode')" \
        #               --proxy-configuration "$(echo $CURRENT_TASK_DEF | jq -c '.proxyConfiguration')" \
        #               --inference-accelerators "$(echo $CURRENT_TASK_DEF | jq -c '.inferenceAccelerators')" \
        #               --ephemeral-storage "$(echo $CURRENT_TASK_DEF | jq -c '.ephemeralStorage')" \
        #               --runtime-platform "$(echo $CURRENT_TASK_DEF | jq -c '.runtimePlatform')" \
        #               --query 'taskDefinition.taskDefinitionArn' \
        #               --output text)

        #             # Update ECS service to use the new task definition revision
        #             aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition $NEW_TASK_DEF_ARN
        #             aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}
        
        # - name: Get current task definition
        #   id: get-task-def
        #   run: |
        #         aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} > current-task-def.json
      
        # - name: Update task definition with new image
        #   id: update-task-def
        #   run: |
        #         NEW_IMAGE="${{ env.IMAGE }}"
        #         CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
        #         jq --arg IMAGE "$NEW_IMAGE" --arg NAME "$CONTAINER_NAME" \
        #           '.taskDefinition.containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)' \
        #           current-task-def.json > updated-task-def.json
      
        # - name: Register updated task definition
        #   id: register-task-def
        #   run: |
        #         aws ecs register-task-definition \
        #           --cli-input-json file://updated-task-def.json \
        #           --query 'taskDefinition.taskDefinitionArn' \
        #           --output text > task-def-arn.txt
        #         echo "TASK_DEF_ARN=$(cat task-def-arn.txt)" >> $GITHUB_ENV
      
        # - name: Deploy updated task definition
        #   run: |
        #         aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition ${{ env.TASK_DEF_ARN }}
        #         aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}